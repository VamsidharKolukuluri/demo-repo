# -*- coding: utf-8 -*-
"""skip_list_routing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a_s-O5tQiJhfXerjzqv23QRezL0D9h_z
"""

import random

class SkipList:
    class Node:
        def __init__(self, key, height):
            self.key = key
            self.quantity = 1
            self.next = [None] * height

    def __init__(self):
        self.head = self.Node(float("-inf"), 0)
        self.tail = self.Node(float("inf"), 0)
        self.num_nodes = 0
        self.head.next.append(self.tail)

    def randomize_height(self):
        height = 1
        while random.randint(0, 1) != 1:
            height += 1
            if height > 2:
                break
        return height

    def search_path(self, key):
        node = self.head
        path = [None] * len(self.head.next)
        for h in range(len(self.head.next) - 1, -1, -1):
            while node.next[h].key < key:
                node = node.next[h]
            path[h] = node
        return path

    def search(self, key):
        predecessor = self.search_path(key)
        target = predecessor[0].next[0]
        return target if target.key == key else None

    def __contains__(self, key):
        return self.search(key) is not None

    def insert(self, key):
        predecessor = self.search_path(key)
        target = predecessor[0].next[0]
        self.num_nodes += 1

        if target.key == key:
            target.quantity += 1
            return

        height = self.randomize_height()
        new_node = self.Node(key, height)

        for h in range(len(predecessor), height):
            self.head.next.append(self.tail)
            predecessor.append(self.head)

        for h in range(height):
            new_node.next[h] = predecessor[h].next[h]
            predecessor[h].next[h] = new_node

    def delete(self, key):
        predecessor = self.search_path(key)
        target = predecessor[0].next[0]

        if target.key != key:
            return

        self.num_nodes -= 1

        if target.quantity > 1:
            target.quantity -= 1
            return

        for h in range(len(target.next)):
            predecessor[h].next[h] = target.next[h]
            if predecessor[h] is self.head and predecessor[h].next[h] is self.tail:
                del self.head.next[max(1, h):]

    def __iter__(self):
        node = self.head.next[0]
        while len(node.next) > 0:
            yield node
            node = node.next[0]

    def __len__(self):
        return self.num_nodes

    def _repr_level(self, level):
        return " ".join([str(self.head.key)] + ["-" * len(str(x.key)) if level > len(x.next) - 1 else str(decimal_to_ip(x.key)) for x in self]
                        + [str(self.tail.key)])

    def __repr__(self):
        return "\n".join(self._repr_level(level) for level in range(len(self.head.next) - 1, -1, -1))

def decimal_to_ip(decimal_ip):
    # Convert decimal IP to a string IP address
    octets = []
    for _ in range(4):
        octets.append(str(decimal_ip & 255))
        decimal_ip >>= 8
    return '.'.join(octets[::-1])

def ip_to_decimal(ip_address):
    # Split the IP address into octets
    octets = ip_address.split('.')

    # Ensure there are 4 octets
    if len(octets) != 4:
        raise ValueError("Invalid IP address format")

    # Convert each octet to decimal and calculate the decimal equivalent
    decimal_ip = 0
    for octet in octets:
        decimal_ip = (decimal_ip << 8) | int(octet)

    return decimal_ip

skip_list = SkipList()

ip_address = input("Enter IPs: ").split(", ")
dictionary = {}

for i in ip_address:
    decimal_ip = ip_to_decimal(i)
    dictionary[decimal_ip] = i

for val in dictionary.keys():
    skip_list.insert(val)

print("=> Initial Skip List <=")
print(skip_list)
print("\n")

print("+++ Insert 192.168.1.3 +++")
skip_list.insert(ip_to_decimal('192.168.1.3'))
print(skip_list)
print("\n")

print("+++ Insert 192.168.1.3 +++")
if ip_to_decimal('192.168.1.3') in skip_list:
    print("### Duplicate ###")
else:
    print(skip_list)
print("\n")

print("-=o Search 192.168.1.3 o=-")
s = skip_list.search(ip_to_decimal('192.168.1.3'))
if s:
    print(f"{decimal_to_ip(s.key)} key found")
else:
    print("Key not found")
print("\n")

print("-=o Search 192.168.1.56 o=-")
s = skip_list.search(ip_to_decimal('192.168.1.56'))
if s:
    print(f"{s.key} key found")
else:
    print("Key not found")
print("\n")

print("--- Delete 192.168.1.1 ---")
skip_list.delete(ip_to_decimal('192.168.1.1'))
print(skip_list)
print("\n")

print("--- Delete 192.168.1.56 ---")
skip_list.delete(ip_to_decimal('192.168.1.56'))
s = skip_list.search(ip_to_decimal('192.168.1.56'))
if s:
    print(skip_list)
else:
    print("Key not found")

